#!/bin/sh

# Copy external IRAF package source from the current working directory to
# $PREFIX/iraf_extern/package_name, add any configuration files from the conda
# recipe (eg. ur_extern.pkg), update extern.pkg accordingly, compile the
# package in place and remove any proprietary files. The build is done using
# the installed copy since the package and its dependencies must already be
# defined in IRAF at build time and IRAF packages are installed as a source
# tree anyway.
#
# This script is used by the AstroConda build process; users wanting pre-built
# AstroConda IRAF packages should instead install them with "conda install" or
# "conda create".

# Determine the directory this script lives in (for later use) and source some
# common name definitions from the same place:
script_dir=`dirname "$0"`
script_dir=`cd "$script_dir" && pwd`  # canonical version of path
. "$script_dir/iraf_defs"

# The parameters are effectively conda build variables, which must be set here:
if [ -n "$1" -o -z "$PREFIX" -o -z "$RECIPE_DIR" -o -z "$PKG_NAME" ]; then
    echo "ERROR: `basename "$0"` should be called via \"conda build\""     >&2
    echo "       (with no arguments), to define the necessary environment" >&2
    exit 1
fi

# IRAF must also be defined in the environment:
if [ -z "$iraf" -o -z "$IRAFARCH" ]; then
    echo "ERROR: must configure IRAF environment (. setup_iraf.sh)"        >&2
    exit 1
fi

# Create any new dirs & files with the expected permissions:
umask 022

# Strip any "iraf." from the Conda package name, to get the IRAF equivalent
# and determine the installation path accordingly:
pkg_name=`echo "$PKG_NAME" | sed -e 's|^iraf[.]||'`
pkg_path="${PREFIX}/${extern_dir}/${pkg_name}"

# Create the destination directory, if needed:
if ! mkdir -p "$pkg_path"; then
    echo "ERROR: failed to create $pkg_path" >&2
    exit 1
fi

# Ensure the destination is writeable (a bit redundant but clearer than the
# subsequent message for this case):
if [ ! -w "$pkg_path" ]; then
    echo "ERROR: cannot write to $pkg_path" >&2
    exit 1
fi

# Copy the package source (CWD contents) to its destination:
if ! tar cf - ./ | (cd "$pkg_path" && tar xf -); then
    echo "ERROR: failed to copy source to $pkg_path" >&2
    exit 1
fi

# Add package configuration files from the recipe (any source patches should
# have already been added separately by conda):
for file_name in $ac_iraf_files; do
    file_path="${RECIPE_DIR}/${file_name}"
    if [ -r "$file_path" ]; then
        if ! cp -p "$file_path" "$pkg_path"/; then
            echo "ERROR: failed to copy $file_name to $pkg_path" >&2
            exit 1
        fi
    fi
done

# Define the new package in the (temporary build-time) extern.pkg:
if ! "$script_dir/update_extern_pkg" "$PREFIX" "$pkg_name"; then
    echo "ERROR: failed to update $extern_pkg" >&2
    exit 1
fi

# Continue working in the destination directory:
cd "$pkg_path" || exit 1  # (failure would have to be 1-off race condition...)

# Remove any bin directories that aren't needed for this IRAF architecture and
# ensure we do have those that are needed:
rm -fr bin.*
mkdir bin.generic "bin.$IRAFARCH"
if [ -L bin ]; then  # apart from being safer, there is a bin/ dir in mscdb
    rm -f bin
    ln -s "bin.$IRAFARCH" bin
fi

# Ensure status=0 on reaching the end (not some left-over condition value).
exit 0

# This won't get picked up until checked in!

